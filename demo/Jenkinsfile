// Define el pipeline usando sintaxis Declarativa
pipeline {
    // Define d√≥nde se ejecutar√° este pipeline.
    // 'agent any' significa que Jenkins asignar√° este pipeline a cualquier agente disponible.
    agent any


    environment {
        SCAN_RESULTS_DIR = 'scan-results'
        PROJECT_NAME = 'demo'
        // Definir el directorio de an√°lisis aqu√≠
        JAVA_ANALYSIS_DIR = '../demo/src'  // Cambiar esta ruta seg√∫n necesites
        MAX_FILES_TO_ANALYZE = '10'        // Cambiar este n√∫mero seg√∫n necesites
        AI_MODEL = "google/gemini-2.0-flash-exp:free"
    }
    

    // Define las etapas del pipeline. Cada etapa es una fase l√≥gica del proceso CI/CD.
    stages {
        // Etapa 1: Checkout - Obtener el c√≥digo fuente desde el repositorio SCM.
        // Jenkins se encarga de esto autom√°ticamente al inicio del pipeline
        // y el workspace se establece en la ra√≠z del repositorio (TFM/).
        stage('Checkout') {
            steps {
                echo '>>> Stage: Checkout - Obteniendo el c√≥digo fuente desde SCM...'
                // El workspace inicial ya es la ra√≠z del repositorio (TFM/).
                // Puedes verificarlo con sh 'pwd'
            }
        }


        stage('Checkout & Build') {
            steps {
                echo 'Starting AI-powered security and quality analysis pipeline'
                sh "java -version"
                sh "python3 --version"

                // Instalar dependencias Python si no est√°n instaladas
                sh "pip3 install requests pathlib --break-system-packages || pip3 install requests pathlib || echo 'Dependencies already installed'"
                                
                // Crear directorio para resultados
                sh "mkdir -p ${SCAN_RESULTS_DIR}"
                
                dir('demo') {
                    sh "mvn -Dmaven.test.failure.ignore=true clean package"
                }
            }
        }

        // Etapa 3: Unit Test Reports - Publicar los resultados de las pruebas unitarias.
        stage('Unit Test Reports') {
            steps {
                echo '>>> Stage: Unit Test Reports - Publicando resultados de pruebas unitarias...'
                // Los reportes de pruebas est√°n en 'demo/target/surefire-reports/'.
                // La ruta es relativa a la ra√≠z del workspace de Jenkins (TFM/).
                junit 'demo/target/surefire-reports/*.xml'
            }
        }
        
        stage('Static Analysis') {
            parallel {
                
                stage('SpotBugs Analysis') {
                    steps {
                        dir('demo') {
                            script {
                                try {
                                    sh "mvn compile spotbugs:spotbugs"
                                    sh "cp target/spotbugsXml.xml ../${SCAN_RESULTS_DIR}/ || echo 'No SpotBugs report found'"
                                } catch (Exception e) {
                                    echo "SpotBugs analysis failed: ${e.getMessage()}"
                                    sh "echo '<BugCollection></BugCollection>' > ../${SCAN_RESULTS_DIR}/spotbugsXml.xml"
                                }
                            }
                        }
                    }
                }
                
                stage('Collect Source Files') {
                    steps {
                        script {
                            // Recopilar archivos Java para an√°lisis AI
                            sh """
                                find demo/src -name "*.java" -type f > ${SCAN_RESULTS_DIR}/java-files.txt
                                echo "Found Java files:"
                                cat ${SCAN_RESULTS_DIR}/java-files.txt
                            """
                        }
                    }
                }
            }
        }
        
        stage('AI-Powered Analysis') {
            steps {
                script {
                    sh 'pwd'
                    sh 'cp demo/ai_code_analyzer.py scan-results/'

                    // Ahora, entra al directorio de los resultados.
                    dir(env.SCAN_RESULTS_DIR) {
                        // Usar withCredentials para inyectar la API key como variable de entorno
                        withCredentials([string(credentialsId: 'openrouter-api-key', variable: 'OPENROUTER_API_KEY')]) {
                            // Ejecutar el script con par√°metros
                            sh """
                                echo "üöÄ Iniciando an√°lisis con IA..."
                                echo "üìÇ Directorio: \${JAVA_ANALYSIS_DIR}"
                                echo "üìä M√°ximo archivos: \${MAX_FILES_TO_ANALYZE}"
                                echo "ü§ñ Modelo IA: \${AI_MODEL}"
                                
                                python3 ai_code_analyzer.py \\
                                    --directory \${JAVA_ANALYSIS_DIR} \\
                                    --max-files \${MAX_FILES_TO_ANALYZE} \\
                                    --model \${AI_MODEL}
                            """
                        }
                    }
                }
            }
        }    

        
        // ==================================================================
        // NUEVA ETAPA: QUALITY GATE
        // ==================================================================
        stage('Quality Gate') {
            steps {
                script {
                    echo '>>> Stage: Quality Gate - Verificando pol√≠ticas de calidad y seguridad...'
                    def resultsFile = "${env.SCAN_RESULTS_DIR}/analysis-results.json"
                    
                    if (fileExists(resultsFile)) {
                        def analysisResults = readJSON(file: resultsFile)
                        def highSeverityVulns = analysisResults.summary.high_severity_vulnerabilities
                        
                        echo "-> Vulnerabilidades de severidad ALTA encontradas: ${highSeverityVulns}"
                        
                        // --- DEFINICI√ìN DEL QUALITY GATE ---
                        if (highSeverityVulns > 0) {
                            // CAMBIO CLAVE: Usamos 'error' para detener el pipeline por completo
                            // y marcarlo como FAILURE.
                            error("‚ùå QUALITY GATE FAILED: Se encontraron ${highSeverityVulns} vulnerabilidades de severidad ALTA. Abortando el pipeline.")
                        } else {
                            echo "‚úÖ QUALITY GATE PASSED: No se encontraron vulnerabilidades de severidad ALTA."
                        }
                        
                    } else {
                        // Si el archivo no existe, tambi√©n es un error que debe detener el proceso.
                        error("‚ùå QUALITY GATE FAILED: No se encontr√≥ el archivo de resultados '${resultsFile}'. No se puede verificar la calidad.")
                    }
                }
            }
        }

        // Etapa 4: Debug Path - Paso opcional para depuraci√≥n
        stage('Debug Path') {
            steps {
                sh 'echo "PATH en Jenkins: $PATH"'
                sh 'echo "Contenido del workspace (profundidad 2):"'
                sh 'ls -R -d */* | head -n 20' // Muestra directorios y archivos hasta 2 niveles de profundidad
                sh 'echo "Contenido de demo/target:"'
                sh 'ls demo/target/' // Para ver el JAR generado
            }
        }

        // Etapa 5: Build Docker Image - Construir la imagen Docker de la aplicaci√≥n.
        stage('Build Docker Image') {
            steps {
                echo '>>> Stage: Build Docker Image - Construyendo la imagen Docker...'
                // Es crucial ejecutar 'docker build' desde la ra√≠z del workspace (TFM/).
                // Esto permite que Docker encuentre el Dockerfile (si est√° en la ra√≠z)
                // y acceda al JAR en 'demo/target/' como parte del contexto de construcci√≥n.
                script {
                    // El comando 'docker build' se ejecuta desde la ra√≠z del repositorio (TFM/).
                    // -f Dockerfile: especifica que el Dockerfile a usar se llama 'Dockerfile' y est√° en la ra√≠z del contexto.
                    // .: el contexto de construcci√≥n es la ra√≠z del repositorio (TFM/).
                    sh 'pwd'
                    sh 'docker build -f demo/Dockerfile -t demo-app .'
                }
            }
        }

        // Etapa 6: Local Deploy - Desplegar el microservicio localmente como un contenedor Docker.
        // Detiene y elimina el contenedor anterior si existe, y luego inicia uno nuevo.
        // Mapear el puerto 9090 del contenedor al 8081 del host.
        stage('Local Deploy') {
            steps {
                echo '>>> Stage: Local Deploy - Desplegando localmente con Docker...'
                // Estos comandos de Docker operan sobre im√°genes y contenedores,
                // por lo que se pueden ejecutar desde cualquier parte del workspace.
                sh 'docker stop demo-app || true' // Detiene si existe, '|| true' evita que falle el pipeline si no existe
                sh 'docker rm demo-app || true'   // Elimina si existe

                // Ejecuta un nuevo contenedor Docker en modo detached (-d).
                // Mapea el puerto 9090 interno del contenedor (donde Spring Boot escucha)
                // al puerto 8081 externo en la m√°quina host de Jenkins.
                sh 'docker run -d -p 8081:9090 --name demo-app demo-app'
                echo '>>> El microservicio deber√≠a estar accesible localmente en http://localhost:8081'
                echo '>>> Verifica los logs del contenedor con: docker logs demo-app'
            }
        }
    }

    // Acciones a realizar despu√©s de que todas las etapas se hayan completado.
    post {
        always {
            // Publicar resultados de tests
            junit(
                allowEmptyResults: true,
                testResults: 'demo/target/surefire-reports/*.xml'
            )
            
             // Publicar reporte HTML de an√°lisis AI
            publishHTML([
                allowMissing: false,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: env.SCAN_RESULTS_DIR,
                reportFiles: 'ai-analysis-report.html',
                reportName: 'AI Security & Quality Report',
                reportTitles: 'AI-Powered Code Analysis'
            ])

            sh 'echo "Ruta actual artifacts"'
            sh 'pwd'
            sh 'ls -la'
            
            // Archivar resultados JSON
            archiveArtifacts artifacts: "*.json, *.html", 
                            allowEmptyArchive: true,
                            fingerprint: true
        }
        
        success {
            echo 'üéâ Pipeline completed successfully!'
            // Aqu√≠ podr√≠as agregar notificaciones de Slack/Teams
        }
        
        failure {
            echo '‚ùå Pipeline failed!'
            // Notificaciones de fallo
        }
        
        unstable {
            echo '‚ö†Ô∏è Pipeline completed with warnings!'
            // Notificaciones de advertencia
        }
    }
}