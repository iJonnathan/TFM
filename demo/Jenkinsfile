// Define el pipeline usando sintaxis Declarativa
pipeline {
    // Define dónde se ejecutará este pipeline.
    // 'agent any' significa que Jenkins asignará este pipeline a cualquier agente disponible.
    agent any

    // Declara las herramientas necesarias. Asegúrate de que estos nombres
    // ('M3', 'JDK-17') coincidan con la configuración de herramientas globales en Jenkins.
    tools {
        maven 'M3'     // Herramienta Maven configurada en Jenkins
        jdk 'JDK-17'   // Herramienta JDK configurada en Jenkins
    }

    // Define las etapas del pipeline. Cada etapa es una fase lógica del proceso CI/CD.
    stages {
        // Etapa 1: Checkout - Obtener el código fuente desde el repositorio SCM.
        // Jenkins se encarga de esto automáticamente al inicio del pipeline
        // y el workspace se establece en la raíz del repositorio (TFM/).
        stage('Checkout') {
            steps {
                echo '>>> Stage: Checkout - Obteniendo el código fuente desde SCM...'
                // El workspace inicial ya es la raíz del repositorio (TFM/).
                // Puedes verificarlo con sh 'pwd'
            }
        }

        // Etapa 2: Build - Compilar el código y empaquetar la aplicación con Maven.
        stage('Build') {
            steps {
                echo '>>> Stage: Build - Compilando y empaquetando con Maven...'
                // **CAMBIO CRÍTICO:** Usamos 'dir' para movernos al subdirectorio 'demo'
                // donde se encuentra el pom.xml de tu aplicación Maven.
                dir('demo') {
                    // Ahora, ejecutamos el comando Maven desde dentro del directorio 'demo/'.
                    // Esto limpia, compila el código, ejecuta las pruebas unitarias y crea el JAR
                    // ejecutable en 'demo/target/'.
                    sh 'mvn clean package'
                }
            }
        }

        // Etapa 3: Unit Test Reports - Publicar los resultados de las pruebas unitarias.
        stage('Unit Test Reports') {
            steps {
                echo '>>> Stage: Unit Test Reports - Publicando resultados de pruebas unitarias...'
                // Los reportes de pruebas están en 'demo/target/surefire-reports/'.
                // La ruta es relativa a la raíz del workspace de Jenkins (TFM/).
                junit 'demo/target/surefire-reports/*.xml'
            }
        }

        // Etapa 4: Debug Path - Paso opcional para depuración
        stage('Debug Path') {
            steps {
                sh 'echo "PATH en Jenkins: $PATH"'
                sh 'echo "Contenido del workspace (profundidad 2):"'
                sh 'ls -R -d */* | head -n 20' // Muestra directorios y archivos hasta 2 niveles de profundidad
                sh 'echo "Contenido de demo/target:"'
                sh 'ls demo/target/' // Para ver el JAR generado
            }
        }

        // Etapa 5: Build Docker Image - Construir la imagen Docker de la aplicación.
        stage('Build Docker Image') {
            steps {
                echo '>>> Stage: Build Docker Image - Construyendo la imagen Docker...'
                // Es crucial ejecutar 'docker build' desde la raíz del workspace (TFM/).
                // Esto permite que Docker encuentre el Dockerfile (si está en la raíz)
                // y acceda al JAR en 'demo/target/' como parte del contexto de construcción.
                script {
                    // El comando 'docker build' se ejecuta desde la raíz del repositorio (TFM/).
                    // -f Dockerfile: especifica que el Dockerfile a usar se llama 'Dockerfile' y está en la raíz del contexto.
                    // .: el contexto de construcción es la raíz del repositorio (TFM/).
                    sh 'ls -la demo/target/'
                    sh 'echo $JAVA_HOME'
                    sh 'pwd'
                    sh 'docker build -f demo/Dockerfile -t microservicio-bienvenida demo/'
                }
            }
        }

        // Etapa 6: Local Deploy - Desplegar el microservicio localmente como un contenedor Docker.
        // Detiene y elimina el contenedor anterior si existe, y luego inicia uno nuevo.
        // Mapear el puerto 9090 del contenedor al 8081 del host.
        stage('Local Deploy') {
            steps {
                echo '>>> Stage: Local Deploy - Desplegando localmente con Docker...'
                // Estos comandos de Docker operan sobre imágenes y contenedores,
                // por lo que se pueden ejecutar desde cualquier parte del workspace.
                sh 'docker stop microservicio-bienvenida || true' // Detiene si existe, '|| true' evita que falle el pipeline si no existe
                sh 'docker rm microservicio-bienvenida || true'   // Elimina si existe

                // Ejecuta un nuevo contenedor Docker en modo detached (-d).
                // Mapea el puerto 9090 interno del contenedor (donde Spring Boot escucha)
                // al puerto 8081 externo en la máquina host de Jenkins.
                sh 'docker run -d -p 8081:9090 --name microservicio-bienvenida microservicio-bienvenida'
                echo '>>> El microservicio debería estar accesible localmente en http://localhost:8081/api/welcome'
                echo '>>> Verifica los logs del contenedor con: docker logs microservicio-bienvenida'
            }
        }
    }

    // Acciones a realizar después de que todas las etapas se hayan completado.
    post {
        always {
            echo '>>> Pipeline finalizado.'
        }
        success {
            echo '>>> ¡Pipeline ejecutado con éxito! El microservicio está desplegado localmente en el puerto 8081.'
        }
        failure {
            echo '>>> El pipeline falló. Revisa los logs de la consola para identificar el problema.'
        }
        unstable {
            echo '>>> El pipeline terminó como inestable (ej: algunas pruebas fallaron).'
        }
    }
}