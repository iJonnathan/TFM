// =============================================================================
//                    JENKINSFILE FINAL Y OPTIMIZADO
// =============================================================================
// Este pipeline integra SAST con Semgrep, an√°lisis con IA robusto,
// y sigue las mejores pr√°cticas de seguridad y estructura de CI/CD.
// =============================================================================

pipeline {
    // Usar cualquier agente disponible como nodo principal
    agent any

    // -------------------------------------------------------------------------
    // HERRAMIENTAS GLOBALES
    // -------------------------------------------------------------------------
    // Aseg√∫rate de que 'M3' y 'JDK-17' est√©n configurados en:
    // Manage Jenkins -> Tools
    tools {
        maven 'M3'
        jdk 'JDK-17'
    }

    // -------------------------------------------------------------------------
    // VARIABLES DE ENTORNO
    // -------------------------------------------------------------------------
    environment {
        // ‚ö†Ô∏è ¬°ACCI√ìN REQUERIDA!
        // Reemplaza 'openrouter-api-key-id' con el ID de tu credencial en Jenkins.
        // La credencial debe ser de tipo "Secret text".
        OPENROUTER_API_KEY = "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"
    
        
        // Variables para mantener la consistencia en todo el pipeline
        SCAN_RESULTS_DIR = 'scan-results'
        PROJECT_DIR = 'demo' // Directorio del proyecto Maven dentro del repositorio
    }

    // =========================================================================
    // ETAPAS DEL PIPELINE
    // =========================================================================
    stages {

        // ---------------------------------------------------------------------
        // ETAPA 1: Preparaci√≥n y Checkout del C√≥digo
        // ---------------------------------------------------------------------
        stage('Setup & Checkout') {
            steps {
                echo '>>> 1. Preparando el entorno y descargando el c√≥digo...'
                
                // Limpiar el workspace para una ejecuci√≥n limpia
                cleanWs()
                
                // ‚ö†Ô∏è ¬°ACCI√ìN REQUERIDA!
                // Reemplaza la URL con la de tu repositorio Git.
                git branch: 'main', url: 'https://github.com/marcogutama/jenkins-pipeline-example.git'
                
                // Verificar versiones de herramientas
                sh "java -version"
                sh "python3 --version"

                // Instalar dependencias de Python
                sh "pip3 install requests pathlib --break-system-packages || echo 'Dependencias de Python ya instaladas'"
                
                // Crear directorio para los resultados de los escaneos
                sh "mkdir -p ${SCAN_RESULTS_DIR}"
            }
        }
        
        // ---------------------------------------------------------------------
        // ETAPA 2: Compilaci√≥n y Pruebas Unitarias
        // ---------------------------------------------------------------------
        stage('Build & Unit Tests') {
            steps {
                echo '>>> 2. Compilando el c√≥digo y ejecutando pruebas unitarias...'
                dir(PROJECT_DIR) {
                    // El flag -Dmaven.test.failure.ignore=true permite que el pipeline contin√∫e
                    // a las etapas de an√°lisis incluso si las pruebas unitarias fallan.
                    sh "mvn -Dmaven.test.failure.ignore=true clean package"
                }
            }
        }

        // ---------------------------------------------------------------------
        // ETAPA 3: An√°lisis de Seguridad y Calidad (en paralelo)
        // ---------------------------------------------------------------------
        stage('Static Analysis (SAST)') {
            failFast true // Si una etapa falla, detiene las dem√°s en paralelo
            parallel {
                // Herramienta SAST principal para encontrar vulnerabilidades en el c√≥digo
                // Herramienta SAST principal para encontrar vulnerabilidades en el c√≥digo
                stage('SAST with Semgrep') {
                    // Ya no se define un 'agent' de Docker aqu√≠
                    steps {
                        script {
                            try {
                                echo 'Running SAST analysis with Semgrep...'
                                // Ejecutamos Semgrep usando un comando 'docker run' directamente.
                                // -v "${pwd}":/src  monta el directorio actual del workspace de Jenkins
                                // dentro del contenedor para que Semgrep pueda escanearlo.
                                sh """
                                    docker run --rm -v "${pwd()}":/src returntocorp/semgrep:latest scan --config auto --json -o /src/semgrep-report.json
                                """
                                // Mueve el reporte al directorio de resultados
                                sh "mv semgrep-report.json ${SCAN_RESULTS_DIR}/"
                                echo '‚úÖ Semgrep analysis completed.'
                            } catch (Exception e) {
                                echo "‚ùå Semgrep analysis failed: ${e.getMessage()}"
                                unstable('Semgrep analysis failed.')
                            }
                        }
                    }
                }
                // Escanea LIBRER√çAS de terceros en busca de vulnerabilidades conocidas
                stage('OWASP Dependency Check') {
                    steps {
                        dir(PROJECT_DIR) {
                            script {
                                try {
                                    echo 'Running OWASP Dependency Check (for library vulnerabilities)...'
                                    sh 'mvn org.owasp:dependency-check-maven:check -Dformat=JSON -DfailBuildOnCVSS=0'
                                    sh "cp target/dependency-check-report.json ../${SCAN_RESULTS_DIR}/"
                                } catch (Exception e) {
                                    echo "‚ö†Ô∏è OWASP Dependency Check failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
                // Encuentra PATRONES DE BUGS comunes en el c√≥digo
                stage('SpotBugs Analysis') {
                    steps {
                        dir(PROJECT_DIR) {
                            script {
                                try {
                                    echo 'Running SpotBugs (for common bug patterns)...'
                                    sh "mvn compile spotbugs:spotbugs"
                                    sh "cp target/spotbugsXml.xml ../${SCAN_RESULTS_DIR}/"
                                } catch (Exception e) {
                                    echo "‚ö†Ô∏è SpotBugs analysis failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ---------------------------------------------------------------------
        // ETAPA 4: An√°lisis Avanzado con IA (Experimental)
        // ---------------------------------------------------------------------
        stage('AI-Powered Analysis (Experimental)') {
            steps {
                script {
                    echo '>>> 4. Generando y ejecutando script de an√°lisis con IA...'
                    // Script de Python mejorado: usa un modelo potente, fuerza la salida JSON
                    // y detiene el pipeline si hay un error (no m√°s fallos silenciosos).
                    // Escribir script Python para an√°lisis con OpenRouter
                    writeFile file: "${SCAN_RESULTS_DIR}/ai_analyzer.py", text: '''import json
import os
import requests
import sys
from pathlib import Path
import xml.etree.ElementTree as ET

class OpenRouterAnalyzer:
    def __init__(self):
        self.api_key = "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"
        self.base_url = "https://openrouter.ai/api/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost:8080",
            "X-Title": "Jenkins CI/CD Security Scanner"
        }
        
    def analyze_code_security(self, code_content, filename):
        """Analizar c√≥digo Java para vulnerabilidades de seguridad"""
        prompt = f"""Act√∫a como un experto en seguridad de aplicaciones Java. Analiza el siguiente c√≥digo fuente para identificar vulnerabilidades de seguridad:

Archivo: {filename}

Dame sugerencias de solucion en base al contexto de cada clase o sentencia con vulnerabilidad.
Busca espec√≠ficamente:
1. Inyecci√≥n SQL
2. Cross-Site Scripting (XSS)
3. Problemas de autenticaci√≥n/autorizaci√≥n
4. Validaci√≥n de entrada insuficiente
5. Exposici√≥n de informaci√≥n sensible
6. Vulnerabilidades de deserializaci√≥n
7. Uso inseguro de criptograf√≠a
8. Path traversal
9. Command injection
10. Problemas de gesti√≥n de sesiones

C√≥digo a analizar:
```java
{code_content}
```

Responde en formato JSON con la siguiente estructura:
{{
    "vulnerabilities": [
        {{
            "type": "tipo de vulnerabilidad",
            "severity": "HIGH|MEDIUM|LOW",
            "line": "n√∫mero de l√≠nea aproximado",
            "description": "descripci√≥n detallada",
            "recommendation": "c√≥mo solucionarlo",
            "cwe_id": "CWE-XXX si aplica"
        }}
    ],
    "security_score": "puntuaci√≥n del 0-10",
    "summary": "resumen ejecutivo de los hallazgos"
}}"""
        
        return self._call_api(prompt, "security")
    
    def analyze_code_quality(self, code_content, filename):
        """Analizar calidad del c√≥digo Java"""
        prompt = f"""Act√∫a como un experto en calidad de c√≥digo Java. Analiza el siguiente c√≥digo para identificar problemas de calidad:

Archivo: {filename}

Eval√∫a:
1. Code smells y anti-patrones
2. Complejidad ciclom√°tica alta
3. Duplicaci√≥n de c√≥digo
4. Problemas de mantenibilidad
5. Violaciones de principios SOLID
6. Uso inadecuado de patrones de dise√±o
7. Gesti√≥n de excepciones
8. Nomenclatura y convenciones
9. Eficiencia y rendimiento
10. Cobertura y calidad de comentarios

C√≥digo a analizar:
```java
{code_content}
```

Responde en formato JSON:
{{
    "quality_issues": [
        {{
            "type": "tipo de problema",
            "severity": "HIGH|MEDIUM|LOW",
            "line": "n√∫mero de l√≠nea aproximado",
            "description": "descripci√≥n del problema",
            "recommendation": "mejora sugerida"
        }}
    ],
    "quality_score": "puntuaci√≥n del 0-10",
    "maintainability_index": "√≠ndice de mantenibilidad",
    "complexity_score": "puntuaci√≥n de complejidad"
}}"""
        
        return self._call_api(prompt, "quality")
    
    def _call_api(self, prompt, analysis_type):
        """Llamar a la API de OpenRouter"""
        payload = {
            "model": "deepseek/deepseek-chat:free",
            "messages": [
                {
                    "role": "user", 
                    "content": prompt
                }
            ],
            "temperature": 0.1,
            "max_tokens": 4000
        }
        
        try:
            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=self.headers,
                json=payload,
                timeout=60
            )
            
            if response.status_code == 200:
                result = response.json()
                content = result["choices"][0]["message"]["content"]
                
                # Intentar extraer JSON del contenido
                try:
                    # Buscar JSON en el contenido
                    start = content.find("{")
                    end = content.rfind("}") + 1
                    if start != -1 and end > start:
                        json_content = content[start:end]
                        return json.loads(json_content)
                    else:
                        return {"error": "No se pudo extraer JSON v√°lido", "raw_content": content}
                except json.JSONDecodeError as e:
                    return {"error": f"JSON inv√°lido: {e}", "raw_content": content}
            else:
                return {"error": f"API Error: {response.status_code}", "message": response.text}
                
        except Exception as e:
            return {"error": f"Exception: {str(e)}"}
    
    def parse_static_analysis(self):
        """Parsear resultados de an√°lisis est√°tico"""
        results = {}
        
        # Parsear OWASP Dependency Check
        owasp_file = Path("dependency-check-report.json")
        if owasp_file.exists():
            try:
                with open(owasp_file, 'r') as f:
                    owasp_data = json.load(f)
                results['owasp'] = owasp_data
            except Exception as e:
                results['owasp'] = {"error": str(e)}
        
        # Parsear SpotBugs
        spotbugs_file = Path("spotbugsXml.xml")
        if spotbugs_file.exists():
            try:
                tree = ET.parse(spotbugs_file)
                root = tree.getroot()
                bugs = []
                for bug in root.findall('.//BugInstance'):
                    bugs.append({
                        'type': bug.get('type', ''),
                        'priority': bug.get('priority', ''),
                        'category': bug.get('category', '')
                    })
                results['spotbugs'] = {'bugs': bugs}
            except Exception as e:
                results['spotbugs'] = {'bugs': [], 'error': str(e)}
        
        return results
    
    def generate_report(self, ai_results, static_results):
        """Generar reporte HTML comprensivo"""
        
        # Calcular estad√≠sticas
        total_vulnerabilities = sum(len(result.get('vulnerabilities', [])) for result in ai_results.values() if isinstance(result, dict))
        total_quality_issues = sum(len(result.get('quality_issues', [])) for result in ai_results.values() if isinstance(result, dict))
        
        high_severity = sum(1 for result in ai_results.values() if isinstance(result, dict) 
                          for vuln in result.get('vulnerabilities', []) 
                          if vuln.get('severity') == 'HIGH')
        
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>AI-Powered Security & Quality Analysis Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 8px; }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }}
        .summary {{ display: flex; justify-content: space-around; margin: 20px 0; }}
        .stat-card {{ background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center; min-width: 150px; }}
        .stat-number {{ font-size: 2em; font-weight: bold; color: #495057; }}
        .severity-high {{ color: #dc3545; font-weight: bold; }}
        .severity-medium {{ color: #fd7e14; font-weight: bold; }}
        .severity-low {{ color: #28a745; }}
        .section {{ margin: 20px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 8px; }}
        .vulnerability {{ background-color: #fff3cd; padding: 10px; margin: 10px 0; border-left: 4px solid #ffc107; }}
        .quality-issue {{ background-color: #e7f3ff; padding: 10px; margin: 10px 0; border-left: 4px solid #007bff; }}
        .ai-insight {{ background-color: #e8f5e8; padding: 15px; margin: 10px 0; border-radius: 5px; }}
        .file-section {{ background-color: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        pre {{ background-color: #f1f3f4; padding: 10px; border-radius: 4px; overflow-x: auto; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è AI-Powered Security & Quality Analysis Report</h1>
            <p>An√°lisis automatizado con IA para vulnerabilidades de seguridad y calidad de c√≥digo</p>
        </div>
        
        <div class="summary">
            <div class="stat-card">
                <div class="stat-number">{total_vulnerabilities}</div>
                <div>Vulnerabilidades</div>
            </div>
            <div class="stat-card">
                <div class="stat-number severity-high">{high_severity}</div>
                <div>Alta Severidad</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{total_quality_issues}</div>
                <div>Problemas de Calidad</div>
            </div>
        </div>"""
        
        # Agregar resultados por archivo
        for filename, results in ai_results.items():
            if isinstance(results, dict) and ('vulnerabilities' in results or 'quality_issues' in results):
                html_content += f"""
        <div class="section">
            <h2>üìÅ {filename}</h2>
            
            <div class="file-section">
                <h3>üîí An√°lisis de Seguridad</h3>"""
                
                vulnerabilities = results.get('vulnerabilities', [])
                if vulnerabilities:
                    for vuln in vulnerabilities:
                        severity_class = f"severity-{vuln.get('severity', 'low').lower()}"
                        html_content += f"""
                <div class="vulnerability">
                    <strong class="{severity_class}">{vuln.get('type', 'Unknown')}</strong> 
                    (Severidad: <span class="{severity_class}">{vuln.get('severity', 'Unknown')}</span>)
                    <br>
                    <strong>L√≠nea:</strong> {vuln.get('line', 'N/A')}
                    <br>
                    <strong>Descripci√≥n:</strong> {vuln.get('description', 'N/A')}
                    <br>
                    <strong>Recomendaci√≥n:</strong> {vuln.get('recommendation', 'N/A')}
                </div>"""
                else:
                    html_content += "<p>‚úÖ No se encontraron vulnerabilidades de seguridad</p>"
                
                html_content += """
            </div>
            
            <div class="file-section">
                <h3>‚ö° An√°lisis de Calidad</h3>"""
                
                quality_issues = results.get('quality_issues', [])
                if quality_issues:
                    for issue in quality_issues:
                        severity_class = f"severity-{issue.get('severity', 'low').lower()}"
                        html_content += f"""
                <div class="quality-issue">
                    <strong>{issue.get('type', 'Unknown')}</strong> 
                    (Severidad: <span class="{severity_class}">{issue.get('severity', 'Unknown')}</span>)
                    <br>
                    <strong>L√≠nea:</strong> {issue.get('line', 'N/A')}
                    <br>
                    <strong>Descripci√≥n:</strong> {issue.get('description', 'N/A')}
                    <br>
                    <strong>Recomendaci√≥n:</strong> {issue.get('recommendation', 'N/A')}
                </div>"""
                else:
                    html_content += "<p>‚úÖ No se encontraron problemas significativos de calidad</p>"
                
                html_content += """
            </div>
        </div>"""
        
        # Agregar resultados de an√°lisis est√°tico
        if static_results:
            html_content += """
        <div class="section">
            <h2>üîç Resultados de An√°lisis Est√°tico</h2>"""
            
            if 'owasp' in static_results and static_results['owasp']:
                html_content += "<h3>OWASP Dependency Check</h3>"
                dependencies = static_results['owasp'].get('dependencies', [])
                vulnerable_deps = [dep for dep in dependencies if dep.get('vulnerabilities')]
                html_content += f"<p>Dependencias analizadas: {len(dependencies)}</p>"
                html_content += f"<p>Dependencias vulnerables: {len(vulnerable_deps)}</p>"
            
            if 'spotbugs' in static_results and static_results['spotbugs']:
                bugs = static_results['spotbugs'].get('bugs', [])
                html_content += f"<h3>SpotBugs</h3><p>Bugs encontrados: {len(bugs)}</p>"
        
        html_content += """
        </div>
        
        <div class="section">
            <h2>üìä Resumen y Recomendaciones</h2>
            <div class="ai-insight">
                <h3>üí° Recomendaciones Principales</h3>
                <ul>
                    <li>Revisar y corregir todas las vulnerabilidades de alta severidad</li>
                    <li>Implementar validaci√≥n de entrada robusta</li>
                    <li>Mejorar la gesti√≥n de excepciones</li>
                    <li>Considerar refactoring para reducir complejidad</li>
                    <li>Agregar m√°s pruebas unitarias y de seguridad</li>
                </ul>
            </div>
        </div>
    </div>
</body>
</html>"""
        
        with open("ai-analysis-report.html", "w", encoding="utf-8") as f:
            f.write(html_content)
        
        # Tambi√©n generar JSON para quality gates
        report_json = {
            "total_vulnerabilities": total_vulnerabilities,
            "high_severity_vulnerabilities": high_severity,
            "total_quality_issues": total_quality_issues,
            "files_analyzed": len(ai_results),
            "ai_results": ai_results,
            "static_results": static_results
        }
        
        with open("analysis-results.json", "w") as f:
            json.dump(report_json, f, indent=2)

def main():
    analyzer = OpenRouterAnalyzer()
    
    # Leer lista de archivos Java
    print("üîç Buscando archivos Java...")
    java_files = list(Path("../demo/src").rglob("*.java"))
    print(f"Archivos Java encontrados: {len(java_files)}")
    
    if not java_files:
        print("‚ùå No se encontraron archivos Java en ../demo/src")
        print("Estructura esperada: ../demo/src/**/*.java")
        # Crear resultados vac√≠os en lugar de fallar
        analyzer.generate_report({}, {})
        return
    
    print(f"Analizando {len(java_files)} archivos Java con IA...")
    
    ai_results = {}
    
    for java_file in java_files[:5]:  # Limitar a 5 archivos para evitar costos excesivos
        try:
            with open(java_file, 'r', encoding='utf-8') as f:
                code_content = f.read()
                
            if len(code_content.strip()) == 0:
                continue
                
            print(f"Analizando: {java_file}")
            
            # An√°lisis de seguridad
            security_result = analyzer.analyze_code_security(code_content, str(java_file))
            
            # An√°lisis de calidad
            quality_result = analyzer.analyze_code_quality(code_content, str(java_file))
            
            # Combinar resultados
            combined_result = {}
            if isinstance(security_result, dict):
                combined_result.update(security_result)
            if isinstance(quality_result, dict):
                combined_result.update(quality_result)
            
            ai_results[str(java_file)] = combined_result
            
        except Exception as e:
            print(f"Error analizando {java_file}: {e}")
            ai_results[str(java_file)] = {"error": str(e)}
    
    # Parsear resultados de an√°lisis est√°tico
    static_results = analyzer.parse_static_analysis()
    
    # Generar reporte
    analyzer.generate_report(ai_results, static_results)
    
    print("‚úÖ An√°lisis completado. Reportes generados:")
    print("- ai-analysis-report.html")
    print("- analysis-results.json")

if __name__ == "__main__":
    main()
'''
                    // Ejecuta el script de Python. La API key se inyecta de forma segura.
                    dir(env.SCAN_RESULTS_DIR) {
                        sh "python3 ai_analyzer.py"
                    }
                }
            }
        }
        
        // ---------------------------------------------------------------------
        // ETAPA 5: Puertas de Calidad (Quality Gates)
        // ---------------------------------------------------------------------
        stage('Quality Gates') {
            steps {
                script {
                    echo '>>> 5. Evaluando resultados contra las puertas de calidad...'
                    
                    // Evaluar resultados de Semgrep
                    def semgrepReport = readFile file: "${SCAN_RESULTS_DIR}/semgrep-report.json", encoding: 'UTF-8'
                    def semgrepResults = new groovy.json.JsonSlurperClassic().parseText(semgrepReport)
                    def semgrepIssues = semgrepResults.results.size()
                    
                    // Evaluar resultados de la IA
                    def aiReport = readFile file: "${SCAN_RESULTS_DIR}/analysis-results.json", encoding: 'UTF-8'
                    def aiResults = new groovy.json.JsonSlurperClassic().parseText(aiReport)
                    def criticalAI_Issues = aiResults.high_severity_vulnerabilities ?: 0

                    echo "=== QUALITY GATES EVALUATION ==="
                    echo "Semgrep Findings: ${semgrepIssues}"
                    echo "High Severity AI Vulnerabilities: ${criticalAI_Issues}"
                    
                    def gates = [
                        'Semgrep Findings': [threshold: 5, current: semgrepIssues], // Umbral para Semgrep
                        'Critical AI Vulns': [threshold: 0, current: criticalAI_Issues]  // Umbral para IA
                    ]
                    
                    def failedGates = []
                    gates.each { gateName, values ->
                        if (values.current > values.threshold) {
                            failedGates.add("${gateName}: ${values.current} encontrados > ${values.threshold} permitidos")
                        } else {
                            echo "‚úÖ ${gateName}: ${values.current} <= ${values.threshold} (PASSED)"
                        }
                    }
                    
                    if (!failedGates.isEmpty()) {
                        unstable("Quality Gates FAILED: ${failedGates.join(', ')}")
                    } else {
                        echo "‚úÖ All quality gates PASSED!"
                    }
                }
            }
        }

        // ---------------------------------------------------------------------
        // ETAPA 6: Construcci√≥n de la Imagen Docker
        // ---------------------------------------------------------------------
        stage('Build Docker Image') {
            steps {
                echo ">>> 6. Construyendo la imagen Docker..."
                // El contexto de build es la ra√≠z del workspace.
                script {
                    sh "docker build -f ${PROJECT_DIR}/Dockerfile -t mi-aplicacion-demo:latest ."
                }
            }
        }

        // ---------------------------------------------------------------------
        // ETAPA 7: Despliegue Local (Opcional)
        // ---------------------------------------------------------------------
        stage('Deploy to Local Docker') {
            steps {
                echo '>>> 7. Desplegando el contenedor Docker localmente...'
                sh 'docker stop mi-aplicacion-demo || true'
                sh 'docker rm mi-aplicacion-demo || true'
                sh 'docker run -d -p 8081:8080 --name mi-aplicacion-demo mi-aplicacion-demo:latest'
                echo '>>> Despliegue completado. Disponible en http://localhost:8081'
            }
        }
    }

    // =========================================================================
    // ACCIONES POST-EJECUCI√ìN
    // =========================================================================
    post {
        always {
            echo 'Finalizando el pipeline. Publicando reportes...'
            
            // Publicar resultados de pruebas unitarias
            junit testResults: "${PROJECT_DIR}/target/surefire-reports/*.xml", allowEmptyResults: true
            
            // Publicar reporte HTML del an√°lisis con IA
            publishHTML(
                allowMissing: true, // No fallar si el reporte no se genera
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: env.SCAN_RESULTS_DIR,
                reportFiles: 'ai-analysis-report.html',
                reportName: 'AI Security & Quality Report'
            )
            
            // Archivar todos los artefactos JSON para su inspecci√≥n
            archiveArtifacts artifacts: "${SCAN_RESULTS_DIR}/*.json, ${SCAN_RESULTS_DIR}/*.xml", 
                           allowEmptyArchive: true
        }
        success {
            echo 'üéâ Pipeline ejecutado con √©xito.'
        }
        failure {
            echo '‚ùå El pipeline fall√≥.'
        }
        unstable {
            echo '‚ö†Ô∏è El pipeline es inestable (ej. fallaron Quality Gates o tests).'
        }
    }
}